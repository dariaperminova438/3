public class HeapSort {
    
    // Основной метод пирамидальной сортировки
    public static void heapSort(int[] arr) {
        // Получаем длину массива
        int n = arr.length;
        
        // Построение max-heap (начальный этап)
        // Начинаем с последнего нелистового узла и движемся к корню
        // n/2 - 1 - это индекс последнего узла, у которого есть потомки
        for (int i = n / 2 - 1; i >= 0; i--) {
            // Преобразуем каждое поддерево в max-heap
            heapify(arr, n, i);
        }
        
        // Последовательно извлекаем элементы из кучи
        // i - текущий размер кучи (уменьшается на каждой итерации)
        for (int i = n - 1; i > 0; i--) {
            // Меняем местами корень (максимальный элемент) с последним элементом кучи
            // Тем самым перемещаем отсортированные элементы в конец массива
            int temp = arr[0];    // Сохраняем корень (максимальный элемент)
            arr[0] = arr[i];      // Последний элемент ставим в корень
            arr[i] = temp;        // Максимальный элемент помещаем в конец
            
            // Восстанавливаем свойство max-heap для уменьшенной кучи
            // Теперь размер кучи = i, корень может нарушать свойства кучи
            heapify(arr, i, 0);
        }
    }
    
    // Метод для преобразования поддерева в max-heap
    // arr - массив, n - размер кучи, i - корень поддерева
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;        // Предполагаем, что корень - наибольший элемент
        int left = 2 * i + 1;   // Индекс левого потомка в массиве
        int right = 2 * i + 2;  // Индекс правого потомка в массиве
        
        // Проверяем, существует ли левый потомок и больше ли он текущего наибольшего
        // left < n - проверка, что индекс не выходит за границы кучи
        if (left < n && arr[left] > arr[largest]) {
            largest = left;     // Обновляем индекс наибольшего элемента
        }
        
        // Проверяем, существует ли правый потомок и больше ли он текущего наибольшего
        if (right < n && arr[right] > arr[largest]) {
            largest = right;    // Обновляем индекс наибольшего элемента
        }
        
        // Если наибольший элемент не корень, нужно сделать обмен
        if (largest != i) {
            // Меняем местами корень с наибольшим потомком
            int swap = arr[i];          // Сохраняем значение корня
            arr[i] = arr[largest];      // Ставим наибольший потомок в корень
            arr[largest] = swap;        // Ставим старое значение корня на место потомка
            
            // Рекурсивно преобразуем затронутое поддерево
            // Теперь узел largest содержит меньшее значение и может нарушать свойства кучи
            heapify(arr, n, largest);
        }
    }
    
    // Метод для тестирования
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        
        System.out.print("Исходный массив: ");
        for (int value : arr) {
            System.out.print(value + " ");
        }
        
        heapSort(arr);
        
        System.out.print("\nОтсортированный массив: ");
        for (int value : arr) {
            System.out.print(value + " ");
        }
    }
}
