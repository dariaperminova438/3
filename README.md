# Анализ разных типов сортировки на разных языках программирования (Перминова Дарья)
# Сортировка выбором 
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальный элемент в неотсортированной части массива и перемещает его в начало, постепенно формируя отсортированную последовательность.

Обьяснение работы алгоритма:
Функция `selection_sort(arr)` отвечает за основную логику алгоритма, последовательно обрабатывая массив. Внешний цикл проходит по всем элементам массива, определяя текущую позицию для размещения минимального элемента. Внутренний цикл выполняет поиск минимального элемента в неотсортированной части массива, сравнивая все элементы справа от текущей позиции. Условие `if arr[j] < arr[min_index]` проверяет, является ли текущий элемент новым минимумом, и при необходимости обновляет индекс минимального элемента. Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на его правильную позицию в отсортированной части массива.

С точки зрения нотации Big O, сортировка выбором имеет квадратичную временную сложность O(n²) во всех случаях — лучшем, среднем и худшем. Это происходит потому, что алгоритм всегда выполняет двойной цикл: внешний проходит по всем элементам массива, а внутренний для каждого элемента последовательно сравнивает все оставшиеся элементы в поисках минимального значения. Количество операций растёт пропорционально квадрату размера входных данных, что делает алгоритм неэффективным для больших массивов. Однако сортировка выбором обладает постоянной пространственной сложностью O(1), так как использует только фиксированное количество дополнительных переменных и выполняет сортировку на месте без использования дополнительной памяти.

# Сортировка обменом (пузырек);
Сортировка обменом (пузырьковая сортировка) (Bubble Sort) — это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

Ключевая особенность: на каждой итерации самый большой элемент "всплывает" в конец массива, подобно пузырьку воздуха в воде.

Обьяснение работы алгоритма:
Функция `bubble_sort(arr)` отвечает за основную логику сортировки, используя вложенные циклы для многократного прохода по массиву. Внешний цикл контролирует общее количество проходов, необходимых для полной сортировки, гарантируя, что каждый элемент займет своё место. Внутренний цикл выполняет попарное сравнение соседних элементов, а условие `if arr[j] > arr[j + 1]` определяет необходимость обмена элементов местами при нарушении порядка сортировки. Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] непосредственно меняет элементы местами, обеспечивая "всплытие" большего элемента к концу массива.

С точки зрения нотации Big O пузырьковая сортировка имеет квадратичную временную сложность O(n²) в худшем и среднем случае, что обусловлено наличием двух вложенных циклов, каждый из которых в худшем случае выполняет порядка n операций. В лучшем случае, когда массив уже отсортирован, оптимизированная версия алгоритма может достигать линейной сложности O(n) благодаря проверке факта отсутствия обменов на первом же проходе. Пространственная сложность алгоритма составляет O(1), так как сортировка выполняется на месте без использования дополнительной памяти, за исключением нескольких временных переменных для обмена элементов.

# Сортировка вставками
Сортировка вставками (Insertion Sort) — это алгоритм сортировки, который последовательно берет каждый элемент массива и вставляет его на правильную позицию в уже отсортированной части массива, сдвигая остальные элементы при необходимости.

Обьяснение работы алгоритма:
Функция `insertion_sort(arr)` реализует основной алгоритм сортировки, последовательно обрабатывая элементы массива. Внешний цикл проходит по всем элементам, начиная со второго, определяя текущий элемент для вставки в отсортированную часть. Ключевая переменная `key` сохраняет значение вставляемого элемента. Внутренний цикл `while` отвечает за сдвиг элементов отсортированной части, которые больше ключевого значения, освобождая место для правильной вставки. Условие `j >= 0 and arr[j] > key` определяет необходимость продолжения сдвига элементов. Финальное присваивание `arr[j + 1] = key` помещает ключевой элемент на его правильную позицию в отсортированной части массива.

С точки зрения нотации Big O сортировка вставками имеет временную сложность O(n²) в худшем и среднем случае, когда массив отсортирован в обратном порядке или элементы расположены случайным образом, поскольку алгоритму требуется выполнить примерно n(n-1)/2 сравнений и перестановок. Однако в лучшем случае, когда массив уже отсортирован, сложность снижается до O(n), так как внутренний цикл выполняется только для проверки условия без фактических перестановок. Пространственная сложность алгоритма составляет O(1), поскольку сортировка выполняется на месте с использованием лишь нескольких временных переменных, что делает алгоритм эффективным по памяти.

# Сортировка слиянием
Сортировка слиянием (Merge Sort) — алгоритм, который делит массив пополам, сортирует каждую часть отдельно, а затем объединяет их в упорядоченный массив.

Обьяснение работы алгоритма:
Функция `mergeSort()` выполняет рекурсивное разделение массива на две половины. Метод разделения создает левый и правый подмассивы через копирование элементов. Рекурсивные вызовы mergeSort(left) и mergeSort(right) сортируют каждую половину. Функция `merge()` объединяет отсортированные подмассивы: основной цикл while сравнивает элементы левого и правого массивов, условие if выбирает меньший элемент для добавления в результат, дополнительные циклы while добавляют оставшиеся элементы из непустого массива. Операции присваивания заполняют исходный массив отсортированными элементами.

С точки зрения нотации Big O сортировка слиянием имеет временную сложность O(n log n) во всех случаях — лучшем, среднем и худшем, что обусловлено рекурсивным разделением массива на log n уровней и выполнением n операций на каждом уровне для слияния подмассивов. Пространственная сложность составляет O(n), поскольку алгоритм требует дополнительной памяти для хранения временных подмассивов в процессе слияния, что делает его менее эффективным по памяти по сравнению с алгоритмами сортировки на месте, но гарантирует стабильную производительность независимо от исходного порядка элементов.

# Сортировка Шелла
Сортировка Шелла (Shellsort) — это алгоритм сортировки, который является улучшенной версией сортировки вставками и работает путем сравнения элементов, расположенных на определенном расстоянии друг от друга (с постепенным уменьшением этого расстояния), что позволяет элементам быстрее занимать свои правильные позиции.

Обьяснение работы алгоритма: 
Функция `shell_sort()` инициализирует начальный промежуток gap как половину длины массива. Внешний цикл `while gap > 0` управляет последовательным уменьшением промежутка. Внутренний цикл `for i in range(gap, n)` обрабатывает элементы, начиная с позиции gap. Переменная `temp` сохраняет значение текущего элемента для вставки. Вложенный цикл `while j >= gap and arr[j - gap] > temp` выполняет сдвиг элементов, превышающих temp, на расстояние gap. Операция `arr[j] = arr[j - gap]` перемещает элемент правее, а `j -= gap` уменьшает индекс на величину промежутка. Финальное присваивание `arr[j] = temp` вставляет сохранённый элемент на корректную позицию. Уменьшение промежутка `gap //= 2` подготавливает следующую итерацию с меньшим шагом.

С точки зрения нотации Big O сложность сортировки Шелла зависит от выбранной последовательности промежутков: для исходной последовательности (n/2, n/4, ..., 1) временная сложность составляет O(n²) в худшем случае, однако на практике средняя производительность обычно находится в диапазоне O(n^(3/2)) — O(n^(5/4)). При использовании оптимальных последовательностей (например, Кнута или Седжвика) сложность улучшается до O(n^(4/3)) — O(n log² n). Пространственная сложность алгоритма всегда O(1), поскольку сортировка выполняется на месте с использованием константного количества дополнительной памяти.

# Быстрая сортировка
Быстрая сортировка (Quick Sort) — это алгоритм «разделяй и властвуй», который выбирает опорный элемент, разделяет массив на две части (элементы меньше опорного и элементы больше опорного) и рекурсивно применяет тот же алгоритм к обеим частям до полной сортировки массива.

