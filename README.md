# Анализ различных типов алгоритмов сортировки и поиска на разных языках программирования (Перминова Дарья)
# Сортировка выбором 
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальный элемент в неотсортированной части массива и перемещает его в начало, постепенно формируя отсортированную последовательность.

Обьяснение работы алгоритма:
Функция `selection_sort(arr)` отвечает за основную логику алгоритма, последовательно обрабатывая массив. Внешний цикл проходит по всем элементам массива, определяя текущую позицию для размещения минимального элемента. Внутренний цикл выполняет поиск минимального элемента в неотсортированной части массива, сравнивая все элементы справа от текущей позиции. Условие `if arr[j] < arr[min_index]` проверяет, является ли текущий элемент новым минимумом, и при необходимости обновляет индекс минимального элемента. Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на его правильную позицию в отсортированной части массива.

O(n²) - время
O(1) - память

1. Временная сложность O(n²) возникает потому, что алгоритм использует два вложенных цикла: внешний проходит по всем элементам массива, а внутренний для каждого элемента последовательно просматривает все оставшиеся элементы в поисках минимального значения, что в сумме дает квадратичное количество операций.
2. Пространственная сложность O(1) объясняется тем, что сортировка выполняется непосредственно в исходном массиве путем перестановки элементов, используя лишь фиксированное количество дополнительных переменных, без выделения дополнительной памяти, зависящей от размера входных данных.

# Сортировка обменом (пузырек);
Сортировка обменом (пузырьковая сортировка) (Bubble Sort) — это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

Обьяснение работы алгоритма:
Функция `bubble_sort(arr)` отвечает за основную логику сортировки, используя вложенные циклы для многократного прохода по массиву. Внешний цикл контролирует общее количество проходов, необходимых для полной сортировки, гарантируя, что каждый элемент займет своё место. Внутренний цикл выполняет попарное сравнение соседних элементов, а условие `if arr[j] > arr[j + 1]` определяет необходимость обмена элементов местами при нарушении порядка сортировки. Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] непосредственно меняет элементы местами, обеспечивая "всплытие" большего элемента к концу массива.

O(n²) - время
O(1) - память

1. Временная сложность O(n²) возникает потому, что алгоритм использует два вложенных цикла, которые многократно сравнивают и обменивают соседние элементы, причем в худшем случае требуется n-1 проходов по массиву размером n, что приводит к квадратичному количеству сравнений.
2. Пространственная сложность O(1) объясняется тем, что все операции обмена выполняются непосредственно в исходном массиве с использованием всего одной временной переменной для обмена элементов, без создания дополнительных структур данных или рекурсивных вызовов.

# Сортировка вставками
Сортировка вставками (Insertion Sort) — это алгоритм сортировки, который последовательно берет каждый элемент массива и вставляет его на правильную позицию в уже отсортированной части массива, сдвигая остальные элементы при необходимости.

Обьяснение работы алгоритма:
Функция `insertion_sort(arr)` реализует основной алгоритм сортировки, последовательно обрабатывая элементы массива. Внешний цикл проходит по всем элементам, начиная со второго, определяя текущий элемент для вставки в отсортированную часть. Ключевая переменная `key` сохраняет значение вставляемого элемента. Внутренний цикл `while` отвечает за сдвиг элементов отсортированной части, которые больше ключевого значения, освобождая место для правильной вставки. Условие `j >= 0 and arr[j] > key` определяет необходимость продолжения сдвига элементов. Финальное присваивание `arr[j + 1] = key` помещает ключевой элемент на его правильную позицию в отсортированной части массива.

O(n²) - время
O(1) - память

1. Временная сложность O(n²) возникает потому, что каждый новый элемент последовательно сравнивается с элементами уже отсортированной части массива, и в худшем случае для каждого из n элементов требуется выполнить до n сравнений и сдвигов.
2. Пространственная сложность O(1) объясняется тем, что все операции сдвига элементов выполняются непосредственно внутри исходного массива, используя лишь одну временную переменную для хранения вставляемого элемента.

# Сортировка слиянием
Сортировка слиянием (Merge Sort) — алгоритм, который делит массив пополам, сортирует каждую часть отдельно, а затем объединяет их в упорядоченный массив.

Обьяснение работы алгоритма:
Функция `mergeSort()` выполняет рекурсивное разделение массива на две половины. Метод разделения создает левый и правый подмассивы через копирование элементов. Рекурсивные вызовы mergeSort(left) и mergeSort(right) сортируют каждую половину. Функция `merge()` объединяет отсортированные подмассивы: основной цикл while сравнивает элементы левого и правого массивов, условие if выбирает меньший элемент для добавления в результат, дополнительные циклы while добавляют оставшиеся элементы из непустого массива. Операции присваивания заполняют исходный массив отсортированными элементами.

O(n log n) - время
O(n) - память

1. Временная сложность O(n log n) возникает потому, что алгоритм рекурсивно делит массив пополам (log n операций), а затем выполняет слияние отсортированных частей за линейное время (n операций на каждом уровне рекурсии).
2. Пространственная сложность O(n) объясняется тем, что для операции слияния требуется создание дополнительного массива, размер которого пропорционален размеру исходных данных, а также использование стека вызовов при рекурсивной реализации.

# Сортировка Шелла
Сортировка Шелла (Shellsort) — это алгоритм сортировки, который является улучшенной версией сортировки вставками и работает путем сравнения элементов, расположенных на определенном расстоянии друг от друга (с постепенным уменьшением этого расстояния), что позволяет элементам быстрее занимать свои правильные позиции.

Обьяснение работы алгоритма: 
Функция `shell_sort()` инициализирует начальный промежуток gap как половину длины массива. Внешний цикл `while gap > 0` управляет последовательным уменьшением промежутка. Внутренний цикл `for i in range(gap, n)` обрабатывает элементы, начиная с позиции gap. Переменная `temp` сохраняет значение текущего элемента для вставки. Вложенный цикл `while j >= gap and arr[j - gap] > temp` выполняет сдвиг элементов, превышающих temp, на расстояние gap. Операция `arr[j] = arr[j - gap]` перемещает элемент правее, а `j -= gap` уменьшает индекс на величину промежутка. Финальное присваивание `arr[j] = temp` вставляет сохранённый элемент на корректную позицию. Уменьшение промежутка `gap //= 2` подготавливает следующую итерацию с меньшим шагом.

O(n log²n) - время
O(1) - память

1. Время O(n log²n) потому что алгоритм несколько раз проходит по массиву с разным шагом сравнения, и при оптимальном выборе шагов количество операций растёт медленнее чем n².
2. Память O(1) потому что алгоритм просто переставляет элементы внутри исходного массива, используя только несколько временных переменных для хранения значений.

# Быстрая сортировка
Быстрая сортировка (Quick Sort) — это алгоритм «разделяй и властвуй», который выбирает опорный элемент, разделяет массив на две части (элементы меньше опорного и элементы больше опорного) и рекурсивно применяет тот же алгоритм к обеим частям до полной сортировки массива.

Функция `partition()` выбирает опорный элемент pivot как последний элемент массива. Переменная `i` отслеживает позицию для элементов меньше опорного. Цикл `for` проходит по всем элементам массива, условие `if (arr[j] <= pivot)` проверяет элементы на соответствие критерию. Операция `swap(arr[i], arr[j])` перемещает меньшие элементы влево. Финальный `swap(arr[i + 1], arr[high])` устанавливает опорный элемент на correct позицию. Функция `quickSort()` рекурсивно вызывает себя для левой и правой частей массива, используя условие `if (low < high)` как базовый случай рекурсии.

O(n log n) - время (в среднем)
O(log n) - память

1. Время O(n log n) получается потому, что алгоритм разбивает массив на части и обрабатывает их независимо. На каждом уровне рекурсии мы просматриваем все n элементов при разделении, а таких уровней получается примерно log n, так как массив каждый раз делится пополам.
2. Память O(log n) требуется потому, что алгоритм использует рекурсию. Каждый рекурсивный вызов запоминает границы обрабатываемого участка массива в стеке вызовов. Поскольку глубина рекурсии составляет log n, то и памяти нужно пропорционально log n для хранения этой информации.

# Пирамидальная сортировка
Пирамидальная сортировка (Heap Sort) — это алгоритм сортировки, который использует структуру данных «куча» (heap) для организации элементов в виде двоичного дерева, где каждый родительский элемент больше (max-heap) или меньше (min-heap) своих дочерних элементов, после чего последовательно извлекает корневой элемент (наибольший или наименьший) и перестраивает кучу до полной сортировки массива.

Обьяснение работы алгоритма: 
Функция `heapSort()` выполняет основную логику алгоритма, начиная с построения max-heap из исходного массива путем вызова heapify() для всех нелистовых узлов, начиная с последнего. После построения кучи функция последовательно извлекает максимальные элементы, перемещая корень кучи в конец массива и уменьшая размер кучи на каждой итерации. Функция `heapify()` отвечает за поддержание свойства max-heap, сравнивая корень поддерева с его потомками и рекурсивно восстанавливая структуру кучи при необходимости обмена элементов. Она вычисляет индексы потомков, находит наибольший элемент среди корня и его детей и, если наибольший элемент не является корнем, выполняет обмен и рекурсивно вызывается для затронутого поддерева.

O(n log n) - время
O(1) - память

1. Время O(n log n) потому что для каждого из n элементов мы выполняем операцию с кучей, которая занимает log n времени. Даже построение начальной кучи из n элементов требует n операций по log n каждая.
2. Память O(1) потому что мы не создаём новую кучу, а переставляем элементы прямо в исходном массиве, используя только несколько временных переменных для обмена элементов.

# Последовательный поиск
Последовательный поиск (линейный поиск) (Linear Search) — это простейший алгоритм поиска, который последовательно проверяет каждый элемент массива или списка до тех пор, пока не найдет искомый элемент или не достигнет конца коллекции.

Обьяснение работы алгоритма:
Функция `linear_search()` является ядром алгоритма линейного поиска и принимает два параметра: массив `arr` для поиска и целевое значение `target`. Она инициализирует цикл `for`, который последовательно перебирает все индексы массива от 0 до `len(arr)-1`. На каждой итерации цикла происходит обращение к элементу массива по текущему индексу и его сравнение с искомым значением через оператор `==`. Если условие выполняется, функция немедленно прерывает выполнение и возвращает индекс найденного элемента с помощью оператора `return`. В случае, если цикл завершает все итерации без обнаружения целевого элемента, функция возвращает специальное значение -1, сигнализирующее об отсутствии элемента в массиве. Этот процесс гарантирует проверку каждого элемента ровно один раз, обеспечивая полный охват данных.

O(n) - время
O(1) - память

1. Временная сложность O(n) возникает потому, что алгоритм последовательно проверяет каждый элемент массива от начала до конца. В худшем случае, когда искомый элемент находится в конце массива или отсутствует, требуется проверить все n элементов, что дает линейную зависимость времени выполнения от размера данных.
2. Пространственная сложность O(1) объясняется тем, что алгоритм использует лишь фиксированное количество дополнительных переменных (например, для хранения текущего индекса и результата поиска), не требуя создания копий массива или других структур данных, размер которых зависел бы от объема входных данных.

# Бинарный (двоичный, дихотомический) поиск
Бинарный поиск (Binary Search) — это алгоритм поиска элемента в отсортированном массиве, который последовательно делит область поиска пополам, сравнивая средний элемент с искомым значением и отбрасывая одну из половин, пока элемент не будет найден или интервал поиска не станет пустым.

Обьяснение работы алгоритма:
Функция binary_search(arr, target) является основной точкой входа в алгоритм. Она принимает отсортированный массив arr и целевое значение target, инициализирует границы поиска left и right, затем запускает цикл while, внутри которого последовательно выполняются три ключевые операции: вычисление середины через mid = left + (right - left) // 2, сравнение элементов через arr[mid] == target, и обновление границ через left = mid + 1 или right = mid - 1 в зависимости от результата сравнения.

O(log n) - время
O(1) - память

1. Временная сложность O(log n) возникает потому, что на каждом шаге алгоритм уменьшает область поиска вдвое. После первой итерации остается n/2 элементов, после второй - n/4, и так до нахождения элемента или завершения поиска. Такой процесс требует не более log₂n итераций.
2. Пространственная сложность O(1) объясняется тем, что алгоритм использует только несколько переменных для хранения левой и правой границ поиска, среднего индекса и результата, не требуя создания дополнительных массивов или рекурсивных вызовов с затратами памяти.

# Интерполирующий поиск 
Интерпрлирующий поиск - это алгоритм поиска в отсортированном массиве, который предсказывает позицию искомого элемента с помощью линейной интерполяции, что ускоряет поиск в равномерно распределенных данных.

Обьяснение работы алгоритма:
Алгоритм интерполирующего поиска работает через рекурсивные вызовы функции interpolationSearch. Сначала проверяется условие if (lo <= hi && x >= arr[lo] && x <= arr[hi]) - корректны ли границы и находится ли искомое значение в диапазоне. Затем вычисляется позиция pos по формуле интерполяции, которая предсказывает местоположение элемента. Если arr[pos] == x, элемент найден. Если arr[pos] < x, поиск продолжается справа через interpolationSearch(arr, pos + 1, hi, x). Если arr[pos] > x, поиск идет слева через interpolationSearch(arr, lo, pos - 1, x). Если условия не выполняются, возвращается -1.

O(log log n) - время (в среднем)
O(1) - память

1. Временная сложность O(log log n) возникает потому, что алгоритм предсказывает позицию искомого элемента с помощью интерполяционной формулы, используя значения данных, что позволяет значительно быстрее сужать область поиска по сравнению с бинарным поиском, особенно при равномерном распределении данных.
2. Пространственная сложность O(1) объясняется тем, что алгоритм работает непосредственно с исходным массивом, используя лишь фиксированное количество переменных для хранения границ поиска и расчетных позиций, без создания дополнительных структур данных.

# Поиск по Фибоначчи 
Поиск по Фибоначчи - это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения точек разделения
массива.

Обьяснение работы алгоритма: 
Функция fibonacciSearch принимает массив arr и значение x. Команды инициализации fibMMm2 = 0, fibMMm1 = 1, fibM = fibMMm2 + fibMMm1 задают числа Фибоначчи. Цикл while (fibM < n) обновляет числа до покрытия размера массива. Команда i = Math.min(offset + fibMMm2, n - 1) вычисляет позицию проверки. Условия if (arr[i] < x) и if (arr[i] > x) определяют направление поиска, обновляя числа Фибоначчи и смещение offset. При нахождении элемента возвращается i, иначе -1.

O(log n) - время
O(1) - память

1. Временная сложность O(log n) возникает потому, что алгоритм делит массив с помощью чисел Фибоначчи, исключая примерно 1/3 элементов на каждом шаге. Такой подход гарантирует, что количество итераций будет логарифмическим относительно размера массива, аналогично бинарному поиску.
2. Пространственная сложность O(1) объясняется тем, что алгоритм использует только несколько переменных для хранения чисел Фибоначчи и текущих индексов поиска, не требуя создания дополнительных массивов или рекурсивных вызовов с затратами памяти.
