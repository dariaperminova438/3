# Анализ разных типов сортировки на разных языках программирования (Перминова Дарья)
# Сортировка выбором 
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальный элемент в неотсортированной части массива и перемещает его в начало, постепенно формируя отсортированную последовательность.

Обьяснение работы алгоритма:
Функция `selection_sort(arr)` отвечает за основную логику алгоритма, последовательно обрабатывая массив. Внешний цикл проходит по всем элементам массива, определяя текущую позицию для размещения минимального элемента. Внутренний цикл выполняет поиск минимального элемента в неотсортированной части массива, сравнивая все элементы справа от текущей позиции. Условие `if arr[j] < arr[min_index]` проверяет, является ли текущий элемент новым минимумом, и при необходимости обновляет индекс минимального элемента. Операция обмена arr[i], arr[min_index] = arr[min_index], arr[i] перемещает найденный минимальный элемент на его правильную позицию в отсортированной части массива.

С точки зрения нотации Big O, сортировка выбором имеет квадратичную временную сложность O(n²) во всех случаях — лучшем, среднем и худшем. Это происходит потому, что алгоритм всегда выполняет двойной цикл: внешний проходит по всем элементам массива, а внутренний для каждого элемента последовательно сравнивает все оставшиеся элементы в поисках минимального значения. Количество операций растёт пропорционально квадрату размера входных данных, что делает алгоритм неэффективным для больших массивов. Однако сортировка выбором обладает постоянной пространственной сложностью O(1), так как использует только фиксированное количество дополнительных переменных и выполняет сортировку на месте без использования дополнительной памяти.

# Сортировка обменом (пузырек);
Сортировка обменом (пузырьковая сортировка) (Bubble Sort) — это простой алгоритм сортировки, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

Ключевая особенность: на каждой итерации самый большой элемент "всплывает" в конец массива, подобно пузырьку воздуха в воде.

Обьяснение работы алгоритма:
Функция `bubble_sort(arr)` отвечает за основную логику сортировки, используя вложенные циклы для многократного прохода по массиву. Внешний цикл контролирует общее количество проходов, необходимых для полной сортировки, гарантируя, что каждый элемент займет своё место. Внутренний цикл выполняет попарное сравнение соседних элементов, а условие `if arr[j] > arr[j + 1]` определяет необходимость обмена элементов местами при нарушении порядка сортировки. Операция обмена arr[j], arr[j + 1] = arr[j + 1], arr[j] непосредственно меняет элементы местами, обеспечивая "всплытие" большего элемента к концу массива.

С точки зрения нотации Big O пузырьковая сортировка имеет квадратичную временную сложность O(n²) в худшем и среднем случае, что обусловлено наличием двух вложенных циклов, каждый из которых в худшем случае выполняет порядка n операций. В лучшем случае, когда массив уже отсортирован, оптимизированная версия алгоритма может достигать линейной сложности O(n) благодаря проверке факта отсутствия обменов на первом же проходе. Пространственная сложность алгоритма составляет O(1), так как сортировка выполняется на месте без использования дополнительной памяти, за исключением нескольких временных переменных для обмена элементов.

# Сортировка вставками
Сортировка вставками (Insertion Sort) — это алгоритм сортировки, который последовательно берет каждый элемент массива и вставляет его на правильную позицию в уже отсортированной части массива, сдвигая остальные элементы при необходимости.

Обьяснение работы алгоритма:
Функция `insertion_sort(arr)` реализует основной алгоритм сортировки, последовательно обрабатывая элементы массива. Внешний цикл проходит по всем элементам, начиная со второго, определяя текущий элемент для вставки в отсортированную часть. Ключевая переменная `key` сохраняет значение вставляемого элемента. Внутренний цикл `while` отвечает за сдвиг элементов отсортированной части, которые больше ключевого значения, освобождая место для правильной вставки. Условие `j >= 0 and arr[j] > key` определяет необходимость продолжения сдвига элементов. Финальное присваивание `arr[j + 1] = key` помещает ключевой элемент на его правильную позицию в отсортированной части массива.

С точки зрения нотации Big O сортировка вставками имеет временную сложность O(n²) в худшем и среднем случае, когда массив отсортирован в обратном порядке или элементы расположены случайным образом, поскольку алгоритму требуется выполнить примерно n(n-1)/2 сравнений и перестановок. Однако в лучшем случае, когда массив уже отсортирован, сложность снижается до O(n), так как внутренний цикл выполняется только для проверки условия без фактических перестановок. Пространственная сложность алгоритма составляет O(1), поскольку сортировка выполняется на месте с использованием лишь нескольких временных переменных, что делает алгоритм эффективным по памяти.

# Сортировка слиянием
Сортировка слиянием (Merge Sort) — алгоритм, который делит массив пополам, сортирует каждую часть отдельно, а затем объединяет их в упорядоченный массив.

Обьяснение работы алгоритма:
Функция `mergeSort()` выполняет рекурсивное разделение массива на две половины. Метод разделения создает левый и правый подмассивы через копирование элементов. Рекурсивные вызовы mergeSort(left) и mergeSort(right) сортируют каждую половину. Функция `merge()` объединяет отсортированные подмассивы: основной цикл while сравнивает элементы левого и правого массивов, условие if выбирает меньший элемент для добавления в результат, дополнительные циклы while добавляют оставшиеся элементы из непустого массива. Операции присваивания заполняют исходный массив отсортированными элементами.

С точки зрения нотации Big O сортировка слиянием имеет временную сложность O(n log n) во всех случаях — лучшем, среднем и худшем, что обусловлено рекурсивным разделением массива на log n уровней и выполнением n операций на каждом уровне для слияния подмассивов. Пространственная сложность составляет O(n), поскольку алгоритм требует дополнительной памяти для хранения временных подмассивов в процессе слияния, что делает его менее эффективным по памяти по сравнению с алгоритмами сортировки на месте, но гарантирует стабильную производительность независимо от исходного порядка элементов.

# Сортировка Шелла
Сортировка Шелла (Shellsort) — это алгоритм сортировки, который является улучшенной версией сортировки вставками и работает путем сравнения элементов, расположенных на определенном расстоянии друг от друга (с постепенным уменьшением этого расстояния), что позволяет элементам быстрее занимать свои правильные позиции.

Обьяснение работы алгоритма: 
Функция `shell_sort()` инициализирует начальный промежуток gap как половину длины массива. Внешний цикл `while gap > 0` управляет последовательным уменьшением промежутка. Внутренний цикл `for i in range(gap, n)` обрабатывает элементы, начиная с позиции gap. Переменная `temp` сохраняет значение текущего элемента для вставки. Вложенный цикл `while j >= gap and arr[j - gap] > temp` выполняет сдвиг элементов, превышающих temp, на расстояние gap. Операция `arr[j] = arr[j - gap]` перемещает элемент правее, а `j -= gap` уменьшает индекс на величину промежутка. Финальное присваивание `arr[j] = temp` вставляет сохранённый элемент на корректную позицию. Уменьшение промежутка `gap //= 2` подготавливает следующую итерацию с меньшим шагом.

С точки зрения нотации Big O сложность сортировки Шелла зависит от выбранной последовательности промежутков: для исходной последовательности (n/2, n/4, ..., 1) временная сложность составляет O(n²) в худшем случае, однако на практике средняя производительность обычно находится в диапазоне O(n^(3/2)) — O(n^(5/4)). При использовании оптимальных последовательностей (например, Кнута или Седжвика) сложность улучшается до O(n^(4/3)) — O(n log² n). Пространственная сложность алгоритма всегда O(1), поскольку сортировка выполняется на месте с использованием константного количества дополнительной памяти.

# Быстрая сортировка
Быстрая сортировка (Quick Sort) — это алгоритм «разделяй и властвуй», который выбирает опорный элемент, разделяет массив на две части (элементы меньше опорного и элементы больше опорного) и рекурсивно применяет тот же алгоритм к обеим частям до полной сортировки массива.

Функция `partition()` выбирает опорный элемент pivot как последний элемент массива. Переменная `i` отслеживает позицию для элементов меньше опорного. Цикл `for` проходит по всем элементам массива, условие `if (arr[j] <= pivot)` проверяет элементы на соответствие критерию. Операция `swap(arr[i], arr[j])` перемещает меньшие элементы влево. Финальный `swap(arr[i + 1], arr[high])` устанавливает опорный элемент на correct позицию. Функция `quickSort()` рекурсивно вызывает себя для левой и правой частей массива, используя условие `if (low < high)` как базовый случай рекурсии.

С точки зрения нотации Big O быстрая сортировка в среднем случае имеет временную сложность O(n log n), поскольку массив рекурсивно делится на части log n раз, и на каждом уровне выполняется O(n) операций сравнения и перестановки. Однако в худшем случае (когда опорный элемент repeatedly выбирается как минимальный или максимальный) сложность деградирует до O(n²). Пространственная сложность составляет O(log n) в среднем случае из-за рекурсивных вызовов, но в худшем случае может достигать O(n). Эффективность алгоритма сильно зависит от выбора опорного элемента и может быть улучшена до O(n log n) во всех случаях при использовании медианы медиан.

# Пирамидальная сортировка
Пирамидальная сортировка (Heap Sort) — это алгоритм сортировки, который использует структуру данных «куча» (heap) для организации элементов в виде двоичного дерева, где каждый родительский элемент больше (max-heap) или меньше (min-heap) своих дочерних элементов, после чего последовательно извлекает корневой элемент (наибольший или наименьший) и перестраивает кучу до полной сортировки массива.

Обьяснение работы алгоритма: 
Функция `heapSort()` выполняет основную логику алгоритма, начиная с построения max-heap из исходного массива путем вызова heapify() для всех нелистовых узлов, начиная с последнего. После построения кучи функция последовательно извлекает максимальные элементы, перемещая корень кучи в конец массива и уменьшая размер кучи на каждой итерации. Функция `heapify()` отвечает за поддержание свойства max-heap, сравнивая корень поддерева с его потомками и рекурсивно восстанавливая структуру кучи при необходимости обмена элементов. Она вычисляет индексы потомков, находит наибольший элемент среди корня и его детей и, если наибольший элемент не является корнем, выполняет обмен и рекурсивно вызывается для затронутого поддерева.

С точки зрения нотации Big O пирамидальная сортировка имеет временную сложность O(n log n) во всех случаях — лучшем, среднем и худшем, поскольку процесс построения кучи выполняется за O(n) операций, а каждый из n этапов извлечения максимального элемента требует O(log n) операций для восстановления свойств кучи. Пространственная сложность составляет O(1) для итеративной реализации, так как сортировка выполняется на месте без использования дополнительной памяти, пропорциональной размеру входных данных, однако рекурсивная версия может требовать O(log n) памяти для стека вызовов.

# Последовательный поиск
Последовательный поиск (линейный поиск) (Linear Search) — это простейший алгоритм поиска, который последовательно проверяет каждый элемент массива или списка до тех пор, пока не найдет искомый элемент или не достигнет конца коллекции.

Обьяснение работы алгоритма:
Функция `linear_search()` является ядром алгоритма линейного поиска и принимает два параметра: массив `arr` для поиска и целевое значение `target`. Она инициализирует цикл `for`, который последовательно перебирает все индексы массива от 0 до `len(arr)-1`. На каждой итерации цикла происходит обращение к элементу массива по текущему индексу и его сравнение с искомым значением через оператор `==`. Если условие выполняется, функция немедленно прерывает выполнение и возвращает индекс найденного элемента с помощью оператора `return`. В случае, если цикл завершает все итерации без обнаружения целевого элемента, функция возвращает специальное значение -1, сигнализирующее об отсутствии элемента в массиве. Этот процесс гарантирует проверку каждого элемента ровно один раз, обеспечивая полный охват данных.

С точки зрения нотации Big O линейный поиск имеет временную сложность O(n) в худшем случае, когда целевой элемент находится в конце массива или отсутствует вовсе, что требует проверки всех n элементов. В лучшем случае сложность составляет O(1), когда искомый элемент находится на первой позиции массива. Средняя временная сложность также равна O(n), так как в среднем требуется проверить половину элементов массива. Пространственная сложность алгоритма является O(1), поскольку он использует только константное количество дополнительной памяти для хранения индексов и временных переменных, не зависящее от размера входных данных.

# Бинарный (двоичный, дихотомический) поиск
Бинарный поиск (Binary Search) — это алгоритм поиска элемента в отсортированном массиве, который последовательно делит область поиска пополам, сравнивая средний элемент с искомым значением и отбрасывая одну из половин, пока элемент не будет найден или интервал поиска не станет пустым.

Обьяснение работы алгоритма:
Конечно! Вот абзац с функциями в кавычках:

Функция binary_search(arr, target) является основной точкой входа в алгоритм. Она принимает отсортированный массив arr и целевое значение target, инициализирует границы поиска left и right, затем запускает цикл while, внутри которого последовательно выполняются три ключевые операции: вычисление середины через mid = left + (right - left) // 2, сравнение элементов через arr[mid] == target, и обновление границ через left = mid + 1 или right = mid - 1 в зависимости от результата сравнения.

Бинарный поиск обладает логарифмической сложностью O(log n), поскольку на каждой итерации размер обрабатываемой части массива уменьшается вдвое. Это означает, что для массива из n элементов количество требуемых операций растет как log₂n. Временная сложность в худшем случае составляет O(log n), когда элемент находится на краю массива или отсутствует. Все операции внутри цикла - вычисление середины, сравнение элементов и обновление границ - выполняются за постоянное время O(1). Пространственная сложность O(1), так как алгоритм использует фиксированный объем памяти независимо от размера входных данных.

# Интерполирующий поиск 
Интерпрлирующий поиск - это алгоритм поиска в отсортированном массиве, который предсказывает позицию искомого элемента с помощью линейной интерполяции, что ускоряет поиск в равномерно распределенных данных.

Обьяснение работы алгоритма:
Алгоритм интерполирующего поиска работает через рекурсивные вызовы функции interpolationSearch. Сначала проверяется условие if (lo <= hi && x >= arr[lo] && x <= arr[hi]) - корректны ли границы и находится ли искомое значение в диапазоне. Затем вычисляется позиция pos по формуле интерполяции, которая предсказывает местоположение элемента. Если arr[pos] == x, элемент найден. Если arr[pos] < x, поиск продолжается справа через interpolationSearch(arr, pos + 1, hi, x). Если arr[pos] > x, поиск идет слева через interpolationSearch(arr, lo, pos - 1, x). Если условия не выполняются, возвращается -1.

С точки зрения Big O, интерполирующий поиск имеет сложность O(log log n) в среднем случае для равномерно распределенных данных, что делает его значительно быстрее бинарного поиска с его O(log n). Однако в худшем случае, когда данные распределены неравномерно, сложность деградирует до O(n). Пространственная сложность составляет O(1) для итеративной версии и O(log log n) для рекурсивной из-за стека вызовов. Алгоритм эффективен когда данные равномерны, но теряет преимущества при неравномерном распределении.
